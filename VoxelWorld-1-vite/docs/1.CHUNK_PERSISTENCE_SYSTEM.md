# Chunk Persistence System - Design Document

**Status**: Design Phase  
**Target**: Electron (Desktop) Application  
**Goal**: Persistent world chunks that survive browser refresh and enable modification tracking

---

## Table of Contents
1. [Problem Statement](#problem-statement)
2. [Architecture Overview](#architecture-overview)
3. [Binary Chunk Format](#binary-chunk-format)
4. [File System Structure](#file-system-structure)
5. [Worker Pipeline](#worker-pipeline)
6. [Modification Tracking](#modification-tracking)
7. [Performance Expectations](#performance-expectations)
8. [Implementation Plan](#implementation-plan)
9. [API Examples](#api-examples)

---

## Problem Statement

### Current Issues
1. **Cache Volatility**: In-memory chunk cache (RAM) is cleared on page refresh
2. **Lost Modifications**: Player block changes (harvesting/placing) don't persist across sessions
3. **Tree Regeneration**: Trees disappear on refresh, then regenerate in different positions
4. **Terrain Inconsistency**: Chunks regenerate with different blocks when revisited after refresh
5. **Dev Workflow**: Force refresh should create new world, but normal navigation should continue existing world
6. **JSON Performance**: Previous JSON-based persistence caused severe lag spikes during parse

### Why In-Memory Cache Fails
```
User workflow:
1. Generate chunks → Store in RAM cache
2. Player breaks blocks → Update RAM cache
3. Force refresh (Ctrl+F5) → RAM cleared
4. Chunks regenerate → Different seed → Different terrain
5. Trees regenerate → Different positions
6. Player modifications → LOST
```

### Solution: File-Based Persistence
```
New workflow:
1. Worker generates chunk → Writes binary file to disk
2. Player requests chunk → Reads binary file from disk
3. Player breaks blocks → Updates binary file on disk
4. Force refresh → Files persist → Same terrain loads
5. Trees → Saved in chunk files → Persist correctly
6. Modifications → Stored as deltas → Always preserved
```

---

## Architecture Overview

### High-Level Flow
```
┌─────────────────────────────────────────────────────────────┐
│                      Player Movement                         │
│                  (trigger chunk request)                     │
└────────────────────────────┬────────────────────────────────┘
                             ↓
                ┌────────────────────────┐
                │ Check if chunk file    │
                │ exists on disk         │
                └────────┬───────────────┘
                         ↓
            ┌────────────┴────────────┐
            ↓                         ↓
    ┌───────────────┐         ┌──────────────┐
    │ File EXISTS   │         │ File MISSING │
    └───────┬───────┘         └──────┬───────┘
            ↓                         ↓
    ┌───────────────┐         ┌──────────────────┐
    │ Read binary   │         │ Worker generates │
    │ file from     │         │ chunk data       │
    │ disk          │         └────────┬─────────┘
    └───────┬───────┘                  ↓
            ↓                  ┌────────────────────┐
    ┌───────────────┐         │ Worker writes      │
    │ Parse binary  │         │ binary to disk     │
    │ to TypedArrays│         └────────┬───────────┘
    └───────┬───────┘                  ↓
            ↓                  ┌────────────────────┐
    ┌───────────────┐         │ Main thread reads  │
    │ Check for     │         │ file from disk     │
    │ .mod file     │         └────────┬───────────┘
    └───────┬───────┘                  ↓
            ↓                          ↓
    ┌───────────────┐         ┌────────────────────┐
    │ Apply mods if │         │ Parse binary       │
    │ exists        │         └────────┬───────────┘
    └───────┬───────┘                  ↓
            ↓                          ↓
            └──────────┬───────────────┘
                       ↓
              ┌────────────────┐
              │ Render chunk   │
              │ to scene       │
              └────────────────┘
```

### Key Principles

1. **Worker Generates & Writes**: Web worker generates chunk data AND writes binary file directly to disk
2. **File is Source of Truth**: Disk files are the primary storage, not RAM
3. **Binary Format Only**: No JSON - binary TypedArrays for zero-parse performance
4. **Electron File System**: Use Node.js `fs` module for synchronous/async file operations
5. **Modification Deltas**: Player changes stored as separate `.mod` files to avoid rewriting entire chunks
6. **Deterministic Generation**: Same seed + coordinates = same chunk (always)

---

## Binary Chunk Format

### File Extension: `.chunk`

### Structure Overview
```
┌─────────────────────────────────────────────────────────┐
│                    HEADER (32 bytes)                    │
├─────────────────────────────────────────────────────────┤
│                 BLOCK DATA (variable)                   │
│  - Positions (Float32Array)                            │
│  - Block Types (Uint16Array)                           │
│  - Colors (Float32Array)                               │
│  - Flags (Uint8Array)                                  │
├─────────────────────────────────────────────────────────┤
│                 TREE DATA (variable)                    │
│  - Tree count                                          │
│  - Tree metadata (positions, types, IDs)               │
└─────────────────────────────────────────────────────────┘
```

### Header Format (32 bytes)
```javascript
Byte Offset | Type    | Field         | Description
------------|---------|---------------|----------------------------------
0-3         | Int32   | chunkX        | Chunk X coordinate
4-7         | Int32   | chunkZ        | Chunk Z coordinate
8-11        | Int32   | seed          | World seed for validation
12-15       | Uint32  | blockCount    | Number of blocks in chunk
16-19       | Uint32  | waterCount    | Number of water blocks
20-23       | Uint32  | treeCount     | Number of trees in chunk
24          | Uint8   | modified      | 0=pristine, 1=modified
25          | Uint8   | version       | Format version (start with 1)
26-31       | Uint8[] | reserved      | Reserved for future use
```

### Block Data Section
```javascript
// Immediately after header (byte 32)
Starting at byte 32:
- positions: Float32Array(blockCount * 3)  // x,y,z for each block
  Size: blockCount * 3 * 4 bytes

- blockTypes: Uint16Array(blockCount)      // block type ID
  Size: blockCount * 2 bytes

- colors: Float32Array(blockCount * 3)     // r,g,b for each block
  Size: blockCount * 3 * 4 bytes

- flags: Uint8Array(blockCount)            // block flags
  Size: blockCount * 1 bytes
```

### Tree Data Section
```javascript
// After block data
- treeCount: Uint32 (4 bytes)
- For each tree:
  - x: Float32
  - y: Float32  
  - z: Float32
  - biomeNameLength: Uint8
  - biomeName: UTF8 string
  - treeType: Uint8 (0=oak, 1=pine, 2=birch, 3=dead, etc.)
  - treeId: Uint32
```

### Writing Binary Format (Worker)
```javascript
function serializeChunk(chunkData) {
    const { chunkX, chunkZ, seed, blockCount, waterBlockCount, 
            positions, blockTypes, colors, flags, trees } = chunkData;
    
    // Calculate total size
    const headerSize = 32;
    const blockDataSize = (blockCount * 3 * 4) + // positions
                          (blockCount * 2) +      // blockTypes
                          (blockCount * 3 * 4) +  // colors
                          (blockCount * 1);       // flags
    
    const treeDataSize = calculateTreeDataSize(trees);
    const totalSize = headerSize + blockDataSize + treeDataSize;
    
    // Create buffer
    const buffer = new ArrayBuffer(totalSize);
    const view = new DataView(buffer);
    
    // Write header
    view.setInt32(0, chunkX, true);
    view.setInt32(4, chunkZ, true);
    view.setInt32(8, seed, true);
    view.setUint32(12, blockCount, true);
    view.setUint32(16, waterBlockCount, true);
    view.setUint32(20, trees.length, true);
    view.setUint8(24, 0); // modified flag
    view.setUint8(25, 1); // version
    
    // Write block data as TypedArrays
    let offset = 32;
    new Float32Array(buffer, offset, blockCount * 3).set(positions);
    offset += blockCount * 3 * 4;
    
    new Uint16Array(buffer, offset, blockCount).set(blockTypes);
    offset += blockCount * 2;
    
    new Float32Array(buffer, offset, blockCount * 3).set(colors);
    offset += blockCount * 3 * 4;
    
    new Uint8Array(buffer, offset, blockCount).set(flags);
    offset += blockCount;
    
    // Write tree data
    writeTreeData(buffer, offset, trees);
    
    return Buffer.from(buffer); // Convert to Node.js Buffer for fs
}
```

### Reading Binary Format (Main Thread)
```javascript
function deserializeChunk(filePath) {
    const buffer = fs.readFileSync(filePath);
    const view = new DataView(buffer.buffer);
    
    // Read header
    const chunkX = view.getInt32(0, true);
    const chunkZ = view.getInt32(4, true);
    const seed = view.getInt32(8, true);
    const blockCount = view.getUint32(12, true);
    const waterBlockCount = view.getUint32(16, true);
    const treeCount = view.getUint32(20, true);
    const modified = view.getUint8(24);
    const version = view.getUint8(25);
    
    // Read block data (zero-copy views)
    let offset = 32;
    const positions = new Float32Array(buffer.buffer, offset, blockCount * 3);
    offset += blockCount * 3 * 4;
    
    const blockTypes = new Uint16Array(buffer.buffer, offset, blockCount);
    offset += blockCount * 2;
    
    const colors = new Float32Array(buffer.buffer, offset, blockCount * 3);
    offset += blockCount * 3 * 4;
    
    const flags = new Uint8Array(buffer.buffer, offset, blockCount);
    offset += blockCount;
    
    // Read tree data
    const trees = readTreeData(buffer, offset, treeCount);
    
    return {
        chunkX, chunkZ, seed, blockCount, waterBlockCount,
        positions, blockTypes, colors, flags, trees
    };
}
```

---

## File System Structure

### Directory Layout
```
VoxelWorld-1-vite/
├── saves/                          # All world saves
│   ├── world_12345/               # Specific world (seed as folder name)
│   │   ├── world.json             # World metadata
│   │   ├── player.json            # Player data
│   │   └── chunks/
│   │       ├── generated/         # Pristine generated chunks
│   │       │   ├── 0_0.chunk
│   │       │   ├── 0_1.chunk
│   │       │   ├── 1_0.chunk
│   │       │   └── ...
│   │       └── modified/          # Modified chunks
│   │           ├── 2_3.chunk      # Full chunk (if heavily modified)
│   │           ├── 2_3.mod        # Delta modifications (if lightly modified)
│   │           └── ...
│   ├── world_67890/               # Another world
│   │   └── ...
│   └── ...
```

### world.json (Metadata)
```json
{
  "seed": 12345,
  "name": "My Awesome World",
  "created": 1728012345000,
  "lastPlayed": 1728023456000,
  "spawnPoint": { "x": 0, "y": 10, "z": 0 },
  "gameMode": "survival",
  "difficulty": "normal",
  "totalPlayTime": 3600000,
  "version": "1.0.0"
}
```

### player.json (Player State)
```json
{
  "position": { "x": 123.5, "y": 12, "z": -45.2 },
  "rotation": { "pitch": 0.5, "yaw": 1.2 },
  "inventory": [
    { "slot": 0, "type": "stone", "count": 64 },
    { "slot": 1, "type": "wood", "count": 32 }
  ],
  "hotbarIndex": 0,
  "health": 20,
  "hunger": 18
}
```

### Chunk File Naming Convention
```
Format: {chunkX}_{chunkZ}.chunk

Examples:
0_0.chunk       → Chunk at world coordinates (0, 0)
-5_10.chunk     → Chunk at world coordinates (-5, 10)
100_-200.chunk  → Chunk at world coordinates (100, -200)
```

### Modification File Naming Convention
```
Format: {chunkX}_{chunkZ}.mod

Examples:
0_0.mod         → Modifications for chunk (0, 0)
-5_10.mod       → Modifications for chunk (-5, 10)
```

---

## Worker Pipeline

### Worker Responsibilities
1. Generate chunk terrain data
2. Serialize to binary format
3. Write binary file to disk
4. Notify main thread of completion

### Worker Implementation (ChunkWorker.js)
```javascript
import fs from 'fs';
import path from 'path';

// Worker receives generation request
self.onmessage = async (e) => {
    const { type, chunkX, chunkZ, seed, chunkSize, worldPath } = e.data;
    
    if (type === 'generate_chunk') {
        try {
            // 1. Generate chunk data (existing logic)
            const chunkData = generateChunkTerrain(chunkX, chunkZ, seed, chunkSize);
            
            // 2. Serialize to binary
            const binaryBuffer = serializeChunk(chunkData);
            
            // 3. Determine file path
            const chunksDir = path.join(worldPath, 'chunks', 'generated');
            if (!fs.existsSync(chunksDir)) {
                fs.mkdirSync(chunksDir, { recursive: true });
            }
            
            const filePath = path.join(chunksDir, `${chunkX}_${chunkZ}.chunk`);
            
            // 4. Write to disk (async for performance)
            await fs.promises.writeFile(filePath, binaryBuffer);
            
            // 5. Notify main thread
            self.postMessage({
                type: 'chunk_ready',
                chunkX,
                chunkZ,
                filePath,
                blockCount: chunkData.blockCount,
                success: true
            });
            
        } catch (error) {
            self.postMessage({
                type: 'chunk_error',
                chunkX,
                chunkZ,
                error: error.message
            });
        }
    }
};
```

### Main Thread Chunk Request (VoxelWorld.js)
```javascript
async requestChunk(chunkX, chunkZ) {
    const worldPath = `./saves/world_${this.worldSeed}`;
    
    // 1. Check if chunk file exists
    const generatedPath = path.join(worldPath, 'chunks', 'generated', `${chunkX}_${chunkZ}.chunk`);
    const modifiedPath = path.join(worldPath, 'chunks', 'modified', `${chunkX}_${chunkZ}.chunk`);
    
    // 2. Priority: modified > generated > generate new
    if (fs.existsSync(modifiedPath)) {
        // Load modified chunk
        const chunkData = deserializeChunk(modifiedPath);
        this.renderChunk(chunkX, chunkZ, chunkData);
        return;
    }
    
    if (fs.existsSync(generatedPath)) {
        // Load generated chunk
        const chunkData = deserializeChunk(generatedPath);
        
        // Check for modifications
        const modPath = path.join(worldPath, 'chunks', 'modified', `${chunkX}_${chunkZ}.mod`);
        if (fs.existsSync(modPath)) {
            const mods = deserializeModifications(modPath);
            applyModifications(chunkData, mods);
        }
        
        this.renderChunk(chunkX, chunkZ, chunkData);
        return;
    }
    
    // 3. Generate new chunk (worker will write file)
    this.worker.postMessage({
        type: 'generate_chunk',
        chunkX,
        chunkZ,
        seed: this.worldSeed,
        chunkSize: this.chunkSize,
        worldPath: worldPath
    });
}

// Worker completion handler
onWorkerMessage(e) {
    const { type, chunkX, chunkZ, filePath } = e.data;
    
    if (type === 'chunk_ready') {
        // Worker wrote file, now read and render
        const chunkData = deserializeChunk(filePath);
        this.renderChunk(chunkX, chunkZ, chunkData);
    }
}
```

---

## Modification Tracking

### Why Delta Files (.mod)?
- **Efficiency**: Don't rewrite entire 50KB chunk file when player breaks 1 block
- **Performance**: Smaller writes = faster saves
- **History**: Could enable undo/redo in future

### Modification File Format (.mod)
```javascript
// Header (16 bytes)
┌────────────────────────────┐
│ chunkX: Int32             │
│ chunkZ: Int32             │
│ modCount: Uint32          │
│ version: Uint8            │
│ reserved: 3 bytes         │
├────────────────────────────┤
│ Modification Records       │
│ (24 bytes each)           │
└────────────────────────────┘

// Each modification record (24 bytes):
- blockIndex: Uint16    (which block in chunk, 0-511)
- action: Uint8         (0=removed, 1=placed, 2=changed)
- newType: Uint16       (new block type ID, if placed/changed)
- newColor: [Uint8, Uint8, Uint8]  (RGB if changed)
- timestamp: Uint32     (when modified, for sync/undo)
- flags: Uint8          (new flags if changed)
- reserved: Uint8
```

### Writing Modifications
```javascript
function saveBlockModification(chunkX, chunkZ, blockIndex, action, newType, color) {
    const worldPath = `./saves/world_${this.worldSeed}`;
    const modPath = path.join(worldPath, 'chunks', 'modified', `${chunkX}_${chunkZ}.mod`);
    
    // Read existing mods or create new
    let mods = [];
    if (fs.existsSync(modPath)) {
        mods = deserializeModifications(modPath);
    }
    
    // Add new modification
    mods.push({
        blockIndex,
        action,
        newType,
        newColor: color,
        timestamp: Date.now(),
        flags: 0
    });
    
    // Serialize and write
    const buffer = serializeModifications(chunkX, chunkZ, mods);
    fs.writeFileSync(modPath, buffer);
    
    // If too many mods (>100), convert to full modified chunk
    if (mods.length > 100) {
        convertToFullModifiedChunk(chunkX, chunkZ);
    }
}
```

### Applying Modifications
```javascript
function applyModifications(chunkData, modifications) {
    for (const mod of modifications) {
        const { blockIndex, action, newType, newColor, flags } = mod;
        
        if (action === 0) { // removed
            // Mark block as air/empty
            chunkData.blockTypes[blockIndex] = 0;
            chunkData.flags[blockIndex] = 0;
        } else if (action === 1 || action === 2) { // placed or changed
            chunkData.blockTypes[blockIndex] = newType;
            chunkData.colors[blockIndex * 3] = newColor[0];
            chunkData.colors[blockIndex * 3 + 1] = newColor[1];
            chunkData.colors[blockIndex * 3 + 2] = newColor[2];
            chunkData.flags[blockIndex] = flags;
        }
    }
    
    return chunkData;
}
```

### Converting to Full Modified Chunk
```javascript
function convertToFullModifiedChunk(chunkX, chunkZ) {
    const worldPath = `./saves/world_${this.worldSeed}`;
    const genPath = path.join(worldPath, 'chunks', 'generated', `${chunkX}_${chunkZ}.chunk`);
    const modPath = path.join(worldPath, 'chunks', 'modified', `${chunkX}_${chunkZ}.mod`);
    const fullModPath = path.join(worldPath, 'chunks', 'modified', `${chunkX}_${chunkZ}.chunk`);
    
    // Load generated chunk
    const chunkData = deserializeChunk(genPath);
    
    // Apply all modifications
    const mods = deserializeModifications(modPath);
    applyModifications(chunkData, mods);
    
    // Mark as modified
    chunkData.modified = 1;
    
    // Write full modified chunk
    const buffer = serializeChunk(chunkData);
    fs.writeFileSync(fullModPath, buffer);
    
    // Delete .mod file
    fs.unlinkSync(modPath);
}
```

---

## Performance Expectations

### File Sizes (8x8x16 chunk = 512 blocks max)
```
Header:           32 bytes
Positions:        512 * 3 * 4 = 6,144 bytes (6 KB)
Block Types:      512 * 2 = 1,024 bytes (1 KB)
Colors:           512 * 3 * 4 = 6,144 bytes (6 KB)
Flags:            512 * 1 = 512 bytes (0.5 KB)
Trees (avg):      ~500 bytes (5 trees @ 100 bytes each)
─────────────────────────────────────────────
Total per chunk:  ~14.5 KB (typical)
                  ~14 KB (no trees)
                  ~20 KB (dense forest)
```

### Performance Targets
```
Operation                    | Target Time  | Notes
─────────────────────────────────────────────────────────────────
Chunk Generation (worker)    | 5-10ms      | Existing performance
Binary Serialization         | 0.5-1ms     | TypedArray copying
File Write (async)           | 1-2ms       | SSD assumed
File Read                    | 0.5-1ms     | Direct buffer read
Binary Deserialization       | 0.1-0.5ms   | Zero-copy views
Render to Scene              | 2-5ms       | Existing performance
─────────────────────────────────────────────────────────────────
TOTAL (new chunk):           | 10-20ms     | 50-100 FPS maintained
TOTAL (cached chunk):        | 3-8ms       | 125-330 FPS maintained
```

### Memory Usage
```
Current system (in-memory cache):
- 256 chunks cached
- ~14 KB per chunk
- Total: ~3.5 MB RAM

New system (file-based):
- Only active chunks in RAM (render distance)
- Render distance 3 = ~25 chunks loaded
- Total: ~350 KB RAM (10x reduction!)
- Disk usage: ~14 KB per explored chunk
  - 1000 chunks explored = ~14 MB disk
  - 10,000 chunks = ~140 MB disk
```

### Why No Lag Spikes
1. **No JSON.parse()**: Binary reads are instant (memory mapping)
2. **No String Allocation**: TypedArrays are direct buffer views
3. **Async File I/O**: Writes don't block main thread
4. **Small File Sizes**: 14 KB reads are negligible on SSD
5. **Zero-Copy Reads**: No data copying, just buffer views

---

## Implementation Plan

### Phase 1: Binary Format & Serialization (Week 1)
- [ ] Create `ChunkSerializer.js` module
- [ ] Implement `serializeChunk()` function
- [ ] Implement `deserializeChunk()` function
- [ ] Write unit tests for serialization/deserialization
- [ ] Validate binary format with test chunks

### Phase 2: File System Integration (Week 1-2)
- [ ] Update `ChunkWorker.js` to import Node.js `fs`
- [ ] Add file writing to worker after generation
- [ ] Create world folder structure on new game
- [ ] Update Vite config for Node.js in workers
- [ ] Test worker file writing in Electron

### Phase 3: Main Thread File Loading (Week 2)
- [ ] Create `ChunkLoader.js` module
- [ ] Implement file existence checks (generated/modified priority)
- [ ] Add binary file reading
- [ ] Update `generateChunk()` to check files first
- [ ] Remove old in-memory cache system

### Phase 4: Modification Tracking (Week 2-3)
- [ ] Create `ModificationTracker.js` module
- [ ] Implement `.mod` file format
- [ ] Hook into `addBlock()` and `removeBlock()` to save mods
- [ ] Implement mod application on chunk load
- [ ] Add conversion to full modified chunk (>100 mods)

### Phase 5: World Management (Week 3)
- [ ] Add world creation (folder setup)
- [ ] Add world deletion (cleanup files)
- [ ] Update save/load to use world folders
- [ ] Add world export/import (zip files)
- [ ] Dev menu: "New World" button

### Phase 6: Testing & Optimization (Week 3-4)
- [ ] Performance profiling (file I/O timing)
- [ ] Memory leak detection
- [ ] Large world stress testing (1000+ chunks)
- [ ] Modification stress testing (heavy mining)
- [ ] Cross-platform testing (Windows/Linux/Mac)

### Phase 7: Documentation & Handoff (Week 4)
- [ ] API documentation
- [ ] Architecture diagrams
- [ ] Developer guide
- [ ] User guide (world management)

---

## API Examples

### Creating a New World
```javascript
// VoxelWorld.js
async createNewWorld(worldName, seed = null) {
    // Generate seed if not provided
    this.worldSeed = seed || this.generateInitialSeed();
    
    // Create world directory structure
    const worldPath = `./saves/world_${this.worldSeed}`;
    await fs.promises.mkdir(path.join(worldPath, 'chunks', 'generated'), { recursive: true });
    await fs.promises.mkdir(path.join(worldPath, 'chunks', 'modified'), { recursive: true });
    
    // Create world metadata
    const worldData = {
        seed: this.worldSeed,
        name: worldName,
        created: Date.now(),
        lastPlayed: Date.now(),
        spawnPoint: { x: 0, y: 10, z: 0 },
        gameMode: 'survival',
        version: '1.0.0'
    };
    
    await fs.promises.writeFile(
        path.join(worldPath, 'world.json'),
        JSON.stringify(worldData, null, 2)
    );
    
    // Create player data
    const playerData = {
        position: { x: 0, y: 10, z: 0 },
        rotation: { pitch: 0, yaw: 0 },
        inventory: [],
        hotbarIndex: 0,
        health: 20
    };
    
    await fs.promises.writeFile(
        path.join(worldPath, 'player.json'),
        JSON.stringify(playerData, null, 2)
    );
    
    console.log(`🌍 Created new world: ${worldName} (seed: ${this.worldSeed})`);
}
```

### Loading Existing World
```javascript
async loadWorld(worldSeed) {
    const worldPath = `./saves/world_${worldSeed}`;
    
    // Load world metadata
    const worldData = JSON.parse(
        await fs.promises.readFile(path.join(worldPath, 'world.json'), 'utf8')
    );
    
    this.worldSeed = worldData.seed;
    this.seededRandom = this.createSeededRandom(this.worldSeed);
    
    // Load player data
    const playerData = JSON.parse(
        await fs.promises.readFile(path.join(worldPath, 'player.json'), 'utf8')
    );
    
    this.player.position = playerData.position;
    this.player.rotation = playerData.rotation;
    this.inventory = playerData.inventory;
    
    // Update last played
    worldData.lastPlayed = Date.now();
    await fs.promises.writeFile(
        path.join(worldPath, 'world.json'),
        JSON.stringify(worldData, null, 2)
    );
    
    console.log(`🌍 Loaded world: ${worldData.name} (last played: ${new Date(worldData.lastPlayed)})`);
}
```

### Requesting Chunk (Main Thread)
```javascript
async requestChunk(chunkX, chunkZ) {
    const chunkKey = `${chunkX},${chunkZ}`;
    
    // Skip if already loaded
    if (this.loadedChunks.has(chunkKey)) {
        return;
    }
    
    const worldPath = `./saves/world_${this.worldSeed}`;
    const modifiedChunkPath = path.join(worldPath, 'chunks', 'modified', `${chunkX}_${chunkZ}.chunk`);
    const generatedChunkPath = path.join(worldPath, 'chunks', 'generated', `${chunkX}_${chunkZ}.chunk`);
    const modFilePath = path.join(worldPath, 'chunks', 'modified', `${chunkX}_${chunkZ}.mod`);
    
    try {
        // Priority 1: Modified chunk (player changed it heavily)
        if (fs.existsSync(modifiedChunkPath)) {
            const chunkData = deserializeChunk(modifiedChunkPath);
            this.renderChunk(chunkX, chunkZ, chunkData);
            return;
        }
        
        // Priority 2: Generated chunk (may have .mod file)
        if (fs.existsSync(generatedChunkPath)) {
            let chunkData = deserializeChunk(generatedChunkPath);
            
            // Apply modifications if they exist
            if (fs.existsSync(modFilePath)) {
                const mods = deserializeModifications(modFilePath);
                chunkData = applyModifications(chunkData, mods);
            }
            
            this.renderChunk(chunkX, chunkZ, chunkData);
            return;
        }
        
        // Priority 3: Generate new chunk (worker writes to disk)
        this.worker.postMessage({
            type: 'generate_chunk',
            chunkX,
            chunkZ,
            seed: this.worldSeed,
            chunkSize: this.chunkSize,
            worldPath: worldPath
        });
        
    } catch (error) {
        console.error(`❌ Error loading chunk (${chunkX}, ${chunkZ}):`, error);
    }
}
```

### Saving Block Modification
```javascript
async saveBlockModification(x, y, z, action, newType = null) {
    // Calculate chunk coordinates
    const chunkX = Math.floor(x / this.chunkSize);
    const chunkZ = Math.floor(z / this.chunkSize);
    
    // Calculate block index within chunk
    const localX = x - (chunkX * this.chunkSize);
    const localZ = z - (chunkZ * this.chunkSize);
    const blockIndex = (localX * this.chunkSize * 16) + (y * this.chunkSize) + localZ;
    
    const worldPath = `./saves/world_${this.worldSeed}`;
    const modFilePath = path.join(worldPath, 'chunks', 'modified', `${chunkX}_${chunkZ}.mod`);
    
    // Load existing mods
    let mods = [];
    if (fs.existsSync(modFilePath)) {
        mods = deserializeModifications(modFilePath);
    }
    
    // Get block color if placing
    let color = [0, 0, 0];
    if (newType) {
        const blockData = this.getBlockData(newType);
        color = blockData.color;
    }
    
    // Add modification
    mods.push({
        blockIndex,
        action, // 0=removed, 1=placed
        newType: newType || 0,
        newColor: color,
        timestamp: Date.now(),
        flags: 0
    });
    
    // Serialize and save
    const buffer = serializeModifications(chunkX, chunkZ, mods);
    await fs.promises.writeFile(modFilePath, buffer);
    
    // Convert to full chunk if too many mods
    if (mods.length > 100) {
        await this.convertToFullModifiedChunk(chunkX, chunkZ);
    }
}
```

### Deleting World
```javascript
async deleteWorld(worldSeed) {
    const worldPath = `./saves/world_${worldSeed}`;
    
    if (fs.existsSync(worldPath)) {
        // Read world name for confirmation
        const worldData = JSON.parse(
            await fs.promises.readFile(path.join(worldPath, 'world.json'), 'utf8')
        );
        
        // Delete entire world directory
        await fs.promises.rm(worldPath, { recursive: true, force: true });
        
        console.log(`🗑️ Deleted world: ${worldData.name} (seed: ${worldSeed})`);
        return true;
    }
    
    return false;
}
```

### Listing Available Worlds
```javascript
async listWorlds() {
    const savesPath = './saves';
    
    if (!fs.existsSync(savesPath)) {
        return [];
    }
    
    const worldFolders = await fs.promises.readdir(savesPath);
    const worlds = [];
    
    for (const folder of worldFolders) {
        if (folder.startsWith('world_')) {
            const worldPath = path.join(savesPath, folder);
            const worldJsonPath = path.join(worldPath, 'world.json');
            
            if (fs.existsSync(worldJsonPath)) {
                const worldData = JSON.parse(
                    await fs.promises.readFile(worldJsonPath, 'utf8')
                );
                
                worlds.push({
                    seed: worldData.seed,
                    name: worldData.name,
                    created: worldData.created,
                    lastPlayed: worldData.lastPlayed,
                    path: worldPath
                });
            }
        }
    }
    
    // Sort by last played (most recent first)
    worlds.sort((a, b) => b.lastPlayed - a.lastPlayed);
    
    return worlds;
}
```

### Dev Menu: New World Button
```javascript
// In menu system
async onNewWorldClick() {
    const worldName = prompt('Enter world name:', 'New World');
    if (!worldName) return;
    
    const useCustomSeed = confirm('Use custom seed?');
    let seed = null;
    
    if (useCustomSeed) {
        const seedInput = prompt('Enter seed (number):');
        seed = parseInt(seedInput) || null;
    }
    
    // Clear current world
    this.clearWorld();
    
    // Create new world
    await this.createNewWorld(worldName, seed);
    
    // Start game
    this.startGame();
}
```

---

## Migration from Current System

### What Changes
```
REMOVED:
❌ In-memory ChunkCache (RAM-based)
❌ Cache eviction logic
❌ Cache size limits (256 chunks)
❌ Tree cache (treeCache Map)
❌ cleanupDistantChunks() cache cleanup

ADDED:
✅ ChunkSerializer module (binary format)
✅ File system integration in worker
✅ File-based chunk loading
✅ Modification tracking (.mod files)
✅ World folder management
✅ World metadata (world.json)

MODIFIED:
🔄 generateChunk() - checks files first
🔄 addBlock()/removeBlock() - saves modifications
🔄 Worker - writes files after generation
🔄 unloadChunk() - no cache removal, just scene cleanup
```

### Backward Compatibility
```javascript
// Migrate old saves to new format
async migrateOldSave() {
    const oldSave = localStorage.getItem('NebulaWorld');
    if (!oldSave) return;
    
    const saveData = JSON.parse(oldSave);
    
    // Create new world
    await this.createNewWorld('Migrated World', saveData.worldSeed);
    
    // Convert modified blocks to .mod files
    for (const block of saveData.modifiedBlocks) {
        await this.saveBlockModification(
            block.x, block.y, block.z,
            block.removed ? 0 : 1,
            block.type
        );
    }
    
    // Save player data
    const worldPath = `./saves/world_${saveData.worldSeed}`;
    await fs.promises.writeFile(
        path.join(worldPath, 'player.json'),
        JSON.stringify({
            position: saveData.playerPosition,
            inventory: saveData.inventory
        }, null, 2)
    );
    
    console.log('✅ Migrated old save to new file-based format');
}
```

---

## Future Enhancements

### Multiplayer Support
- Share world folder via network
- Sync `.mod` files between clients
- Conflict resolution (timestamp-based)

### World Export/Import
```javascript
async exportWorld(worldSeed) {
    const worldPath = `./saves/world_${worldSeed}`;
    const exportPath = `./exports/world_${worldSeed}.zip`;
    
    // Zip entire world folder
    await zipFolder(worldPath, exportPath);
    
    return exportPath;
}
```

### Chunk Compression
- Compress chunks with LZ4/Brotli before writing
- 50-70% size reduction possible
- Trade CPU time for disk space

### Lazy Loading Optimization
- Load chunks in background (Web Workers)
- Preload chunks in movement direction
- Unload chunks outside render distance * 2

### Advanced Modification Tracking
- Undo/redo system (replay modifications)
- Modification history per chunk
- Player attribution (who modified what)

---

## Troubleshooting

### Common Issues

**Issue: Files not persisting after refresh**
- Check Electron has file system permissions
- Verify `worldPath` is correct
- Check console for file write errors

**Issue: Chunk terrain looks different**
- Verify seed is same (check `world.json`)
- Check worker is using correct seed
- Validate binary serialization (header seed field)

**Issue: Performance lag when loading chunks**
- Profile file read times (should be <1ms)
- Check SSD vs HDD (HDD will be slower)
- Verify no JSON parsing happening

**Issue: Modified blocks not saving**
- Check `.mod` file is created
- Verify `saveBlockModification()` is called
- Check file write permissions

---

## Questions for Team

1. **Storage Location**: Where should `saves/` folder be?
   - Option A: Inside app directory (portable)
   - Option B: User documents folder (standard)
   - Option C: Configurable by user

2. **World Limit**: Should we limit number of worlds?
   - No limit (user manages disk space)
   - Limit to 10 worlds
   - Warn when disk usage > 1GB

3. **Auto-Save Frequency**: How often to save player data?
   - Every 30 seconds
   - On chunk unload
   - Manual save only

4. **Chunk Unload Strategy**: When to unload chunks from memory?
   - Beyond render distance * 2
   - After 60 seconds inactive
   - Never (keep all in memory)

5. **Backup System**: Should we auto-backup worlds?
   - Daily backups (keep last 3)
   - On quit backup
   - Manual backup only

---

## Success Criteria

✅ **System is successful when:**

1. Player can close/reopen app and terrain is identical
2. Force refresh loads same terrain (from files)
3. Block modifications persist across sessions
4. Trees regenerate in exact same positions
5. No lag spikes when loading chunks (<16ms per chunk)
6. Memory usage stays low (<100 MB for active chunks)
7. Large worlds (10,000+ chunks) work smoothly
8. Dev workflow: "New World" creates fresh seed/terrain

---

**Document Version**: 1.0  
**Last Updated**: October 3, 2025  
**Author**: VoxelWorld Team  
**Status**: Ready for Implementation
